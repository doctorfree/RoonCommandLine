diff -Naur lib/python3.8/site-packages/roonapi-bak/roonapi.py lib/python3.8/site-packages/roonapi/roonapi.py
--- lib/python3.8/site-packages/roonapi-bak/roonapi.py	2021-03-25 13:19:43.508449316 -0700
+++ lib/python3.8/site-packages/roonapi/roonapi.py	2021-03-30 17:41:20.992239239 -0700
@@ -344,6 +344,88 @@
         """
         return self._request(SERVICE_BROWSE + "/load", opts)
 
+    def list_media(self, zone_or_output_id, path):
+        """
+        List the media specified.
+
+        params:
+            zone_or_output_id: where to play the media
+            path: a list allowing roon to find the media
+                  eg ["Library", "Artists", "Neil Young", "Harvest"] or ["My Live Radio", "BBC Radio 4"]
+        """
+
+        opts = {
+            "zone_or_output_id": zone_or_output_id,
+            "hierarchy": "browse",
+            "count": PAGE_SIZE,
+            "pop_all": True,
+        }
+
+        total_count = self.browse_browse(opts)["list"]["count"]
+        del opts["pop_all"]
+
+        load_opts = {
+            "zone_or_output_id": zone_or_output_id,
+            "hierarchy": "browse",
+            "count": PAGE_SIZE,
+            "offset": 0,
+        }
+        items = []
+        searchterm = path[-1]
+        path.pop()
+        for element in path:
+            load_opts["offset"] = 0
+            found = None
+            searched = 0
+
+            LOGGER.debug("Looking for %s", element)
+            while searched < total_count and found is None:
+                items = self.browse_load(load_opts)["items"]
+
+                for item in items:
+                    searched += 1
+                    if item["title"] == element:
+                        found = item
+                        break
+
+                load_opts["offset"] += PAGE_SIZE
+            if searched >= total_count and found is None:
+                LOGGER.error(
+                    "Could not find media path element '%s' in %s",
+                    element,
+                    [item["title"] for item in items],
+                )
+                return None
+
+            opts["item_key"] = found["item_key"]
+            load_opts["item_key"] = found["item_key"]
+
+            total_count = self.browse_browse(opts)["list"]["count"]
+
+            load_opts["offset"] = 0
+            items = self.browse_load(load_opts)["items"]
+
+        LOGGER.debug("Searching Playlists for %s", searchterm)
+        load_opts["offset"] = 0
+        searched = 0
+        matched = []
+        while searched < total_count:
+            items = self.browse_load(load_opts)["items"]
+
+            if searchterm == "all":
+                for item in items:
+                    searched += 1
+                    matched.append(item["title"])
+            else:
+                for item in items:
+                    searched += 1
+                    if searchterm in item["title"]:
+                        matched.append(item["title"])
+
+            load_opts["offset"] += PAGE_SIZE
+
+        return matched
+
     def play_media(self, zone_or_output_id, path, action=None):
         """
         Play the media specified.
@@ -448,6 +530,7 @@
         self.browse_browse(opts)
         return True
 
+    # pylint: disable=too-many-return-statements
     def play_id(self, zone_or_output_id, media_id):
         """Play based on the media_id from the browse api."""
         opts = {
@@ -460,16 +543,17 @@
         try:
             if header_result["list"]["level"] == 0:
                 LOGGER.info("Initial load started playback")
-                return
-        except NameError:
-            pass
+                return True
+        except (NameError, KeyError, TypeError):
+            LOGGER.error("Could not play id:%s, result: %s", media_id, header_result)
+            return False
 
         if header_result is None:
             LOGGER.error(
                 "Playback requested of unsupported id: %s",
                 media_id,
             )
-            return
+            return False
 
         result = self.browse_load(opts)
 
@@ -480,7 +564,7 @@
                 "Playback requested but item is a list, not a playable action or action_list id: %s",
                 media_id,
             )
-            return
+            return False
 
         if hint == "action_list":
             opts["item_key"] = first_item["item_key"]
@@ -490,7 +574,7 @@
                     "Playback requested of unsupported id: %s",
                     media_id,
                 )
-                return
+                return False
             result = self.browse_load(opts)
             first_item = result["items"][0]
             hint = first_item["hint"]
@@ -501,7 +585,7 @@
                 media_id,
                 header_result,
             )
-            return
+            return False
 
         play_action = result["items"][0]
         hint = play_action["hint"]
@@ -513,6 +597,9 @@
                 "Playback requested of unsupported id: %s",
                 media_id,
             )
+            return False
+
+        return True
 
     # private methods
     # pylint: disable=too-many-arguments
@@ -574,7 +661,7 @@
 
     def _server_discovered(self, host, port):
         """(Auto) discovered the roon server on the network."""
-        LOGGER.info("Connecting to Roon server %s:%s" % (host, port))
+        LOGGER.debug("Connecting to Roon server %s:%s" % (host, port))
         ws_address = "ws://%s:%s/api" % (host, port)
         self._host = host
         self._port = port
@@ -587,7 +674,7 @@
 
     def _socket_connected(self):
         """Successfully connected the websocket."""
-        LOGGER.info("Connection with roon websockets (re)created.")
+        LOGGER.debug("Connection with roon websockets (re)created.")
         self.ready = False
         # authenticate / register
         # warning: at first launch the user has to approve the app in the Roon settings.
@@ -597,13 +684,13 @@
         if self._token:
             appinfo["token"] = self._token
         if not self._token:
-            LOGGER.info("The application should be approved within Roon's settings.")
+            LOGGER.debug("The application should be approved within Roon's settings.")
         else:
-            LOGGER.info("Confirming previous registration with Roon...")
+            LOGGER.debug("Confirming previous registration with Roon...")
         self._roonsocket.send_request(SERVICE_REGISTRY + "/register", appinfo)
 
     def _server_registered(self, reginfo):
-        LOGGER.info("Registered to Roon server %s", reginfo["display_name"])
+        LOGGER.debug("Registered to Roon server %s", reginfo["display_name"])
         LOGGER.debug(reginfo)
         self._token = reginfo["token"]
         self._core_id = reginfo["core_id"]
diff -Naur lib/python3.8/site-packages/roonapi-bak/roonapisocket.py lib/python3.8/site-packages/roonapi/roonapisocket.py
--- lib/python3.8/site-packages/roonapi-bak/roonapisocket.py	2021-03-25 13:19:43.508449316 -0700
+++ lib/python3.8/site-packages/roonapi/roonapisocket.py	2021-03-25 12:14:05.869963252 -0700
@@ -137,9 +137,9 @@
                 request_id = int(line_with_request_id[0].split("Request-Id: ")[1])
 
             if "Content-Type:" in message:
-                # Looks like roon adds an extra newline after the header, so use this to find content
-                # https://github.com/RoonLabs/node-roon-api/blob/master/moomsg.js#L45
-                body = message.split("\n\n")[1]
+                # Roon uses a blank line after the header to indicate body.
+                # See https://github.com/RoonLabs/node-roon-api/blob/master/moomsg.js#L45
+                body = "".join(message.split("\n\n")[1:])
             elif "Logging:" not in message:
                 body = header
             if body and "{" in body:
